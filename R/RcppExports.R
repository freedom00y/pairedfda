# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' One EM iterate
#' @param oldpara parameter set from the last step
#' @param data postprocessed data
#' @param lambda tuning parameter
#' @return new parameter set
#' @keywords internal
EM <- function(oldpara, data, lambda) {
    .Call(`_pairedfda_EM`, oldpara, data, lambda)
}

#' Estimations
#' 
#' Use this function to estimate parameters set 
#' 
#' @param data Processed data. Use "predata" to preprocess the raw data first.
#' @param lambda Tuning parameter, a vector with 4 components. The tuning parameters shows as the following order, the first mean curve \eqn{(\lambda_\mu)}, the second mean curve \eqn{(\lambda_\nu)}, the first pcs \eqn{(\lambda_f)}, the second pcs \eqn{(\lambda_g)}.
#' @param tol Tolerance of the EM algorithm
#' @param ka Number of pcs for the first reponse variable
#' @param kb Number of pcs for the second reponse variable
#' @param maxiter Maximum iteration time, the default is 100 times
#' 
#' @return the estimation of the parameters
#' 
#' @details  We suppose the model is 
#' \deqn{Y_i = B_i \theta_\mu + B_i f \alpha_i + \epsilon_i, Z_i = B_i \theta_\nu + B_i g \beta_i + \xi_i,}
#' where \eqn{(\alpha_i, \beta_i)} and residuals follow normal distribution. We denote that 
#' \deqn{(\alpha_i, \beta_i) \sim N(0,\Sigma_{\alpha\beta}), \epsilon_i\sim N(0,\sigma_\epsilon^2), \xi_i\sim N(0,\sigma_\xi^2),}
#' and \eqn{\Sigma_{\alpha\beta} = (D_a , C ; C^T , Db)}.
#' This function returns the estimation of \eqn{\sigma^2_\epsilon,\sigma^2_\xi,\theta_\mu,\theta_\nu,\theta_f,\theta_g,Da,Db,C}.
#' 
#' @examples 
#' rawdata = gen_data(n=50)
#' visit = seq(0,100,20)
#' data = predata(nobs = rawdata$nobs, 
#'                time = rawdata$time,  
#'                y = rawdata$y, 
#'                z = rawdata$z, 
#'                knots = visit, 
#'                order = 3)
#' ## without penalty
#' lambda = c(0,0,0,0)
#' pt_nopen = minEM(data, lambda, ka=1, kb=2, tol = 1e-4, maxiter = 100)
#' ## with penalty
#' lambda_pen = c(6000,6000,16000,16000,16000)
#' pt_pen = minEM(data, lambda_pen, ka=1, kb=2, tol = 1e-4, maxiter = 100)
#' 
#' @export
minEM <- function(data, lambda, ka, kb, tol = 1e-4, maxiter = 100L) {
    .Call(`_pairedfda_minEM`, data, lambda, ka, kb, tol, maxiter)
}

#' Evaluate the loglikelihood value
#' @param data postprocessed data
#' @param para parameter set
#' @return -2*log-likelihood value
#' @keywords internal
loglike <- function(data, para) {
    .Call(`_pairedfda_loglike`, data, para)
}

#' orthogonalize the covariance matrix
#' @param Th theta before orthogonalize
#' @param V covariance matrix before
#' @return orthogonalized theta and covariance matrix
#' @keywords internal 
orth_algo <- function(Th, V) {
    .Call(`_pairedfda_orth_algo`, Th, V)
}

